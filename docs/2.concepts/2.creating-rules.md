# Creating Rules

> Learn how to create custom validation rules for your project.

## Basic Rule Structure

Use `defineCodeRule()` to create a validation rule:

```typescript
import { defineCodeRule } from '../claude-code-validator';

export const myRule = defineCodeRule({
  name: 'my-rule',
  description: 'Description of what this rule checks',

  shouldRun: (context) => {
    // Determine if rule should run
    return context.filePath.endsWith('.ts');
  },

  validate(context) {
    const errors: string[] = [];

    // Check for patterns
    if (context.content.includes('bad-pattern')) {
      errors.push('‚ùå Error message here');
    }

    return errors;
  }
});
```

## Pattern-Based Rules

For simple regex-based validation, define patterns first:

```typescript
import { defineCodeRule } from '../claude-code-validator';
import type { PatternRule } from '../claude-code-validator';

const patterns: PatternRule[] = [
  {
    regex: /OldAPI/,
    message: '‚ùå OldAPI is deprecated',
    replacement: 'NewAPI'
  },
  {
    regex: /dangerousFunction/,
    message: '‚ùå dangerousFunction is not allowed',
    replacement: 'safeFunction'
  }
];

export const patternRule = defineCodeRule({
  name: 'pattern-rule',
  description: 'Checks for deprecated patterns',
  shouldRun: (context) => /\.(ts|js)$/.test(context.filePath),

  validate(context) {
    const errors: string[] = [];

    for (const { regex, message, replacement } of patterns) {
      if (regex.test(context.content)) {
        let error = message;
        if (replacement) {
          error += `\n   ‚Üí Use: ${replacement}`;
        }
        error += `\n   üìÑ File: ${context.filePath}`;
        errors.push(error);
      }
    }

    return errors;
  }
});
```

## Component-Based Rules

Check for specific component usage:

```typescript
import { defineCodeRule } from '../claude-code-validator';

const DEPRECATED_COMPONENTS = ['OldButton', 'OldInput', 'OldForm'];

export const componentRule = defineCodeRule({
  name: 'component-rule',
  description: 'Prevents usage of deprecated components',
  shouldRun: (context) => /\.(vue|jsx|tsx)$/.test(context.filePath),

  validate(context) {
    const errors: string[] = [];

    for (const component of DEPRECATED_COMPONENTS) {
      const regex = new RegExp(`<${component}[\\s>]`);
      if (regex.test(context.content)) {
        errors.push(
          `‚ùå <${component}> is deprecated\n` +
          `   ‚Üí Use the new component library instead\n` +
          `   üìÑ File: ${context.filePath}`
        );
      }
    }

    return errors;
  }
});
```

## Prop Validation Rules

Validate component props:

```typescript
import { defineCodeRule } from '../claude-code-validator';

const VALID_COLORS = ['primary', 'secondary', 'error', 'success', 'warning'];

export const propRule = defineCodeRule({
  name: 'prop-rule',
  description: 'Validates color prop values',
  shouldRun: (context) => context.filePath.endsWith('.vue'),

  validate(context) {
    const errors: string[] = [];

    // Match color="value" or :color="value"
    const colorRegex = /:?color=["']([^"']+)["']/g;
    let match;

    while ((match = colorRegex.exec(context.content)) !== null) {
      const color = match[1];

      if (!VALID_COLORS.includes(color)) {
        errors.push(
          `‚ùå Invalid color "${color}"\n` +
          `   ‚Üí Valid colors: ${VALID_COLORS.join(', ')}\n` +
          `   üìÑ File: ${context.filePath}`
        );
      }
    }

    return errors;
  }
});
```

## API Pattern Rules

Enforce API usage patterns:

```typescript
import { defineCodeRule } from '../claude-code-validator';

export const apiRule = defineCodeRule({
  name: 'api-rule',
  description: 'Enforce use of defineModel() macro',
  shouldRun: (context) => context.filePath.endsWith('.vue'),

  validate(context) {
    const errors: string[] = [];

    // Check for old pattern
    const hasModelValueProp = /defineProps[^}]*modelValue[^}]*}/s.test(context.content);
    const hasUpdateEmit = /defineEmits[^}]*update:modelValue[^}]*}/s.test(context.content);

    if (hasModelValueProp && hasUpdateEmit) {
      errors.push(
        `‚ùå Using modelValue prop with update:modelValue emit is outdated\n` +
        `   ‚Üí Use the defineModel() macro instead\n` +
        `   ‚ÑπÔ∏è  Example: const model = defineModel<string>()\n` +
        `   üìÑ File: ${context.filePath}`
      );
    }

    return errors;
  }
});
```

## Async Rules

For rules that need async operations:

```typescript
import { defineCodeRule } from '../claude-code-validator';

export const asyncRule = defineCodeRule({
  name: 'async-rule',
  description: 'Performs async validation',
  shouldRun: () => true,

  async validate(context) {
    const errors: string[] = [];

    // Fetch external data
    const bannedPatterns = await fetchBannedPatterns();

    for (const pattern of bannedPatterns) {
      if (context.content.includes(pattern)) {
        errors.push(
          `‚ùå Pattern "${pattern}" is not allowed\n` +
          `   üìÑ File: ${context.filePath}`
        );
      }
    }

    return errors;
  }
});
```

## Multi-Rule Files

You can export multiple rules from a single file:

```typescript
import { defineCodeRule } from '../claude-code-validator';

export const ruleOne = defineCodeRule({
  name: 'rule-one',
  description: 'First rule',
  shouldRun: () => true,
  validate: () => []
});

export const ruleTwo = defineCodeRule({
  name: 'rule-two',
  description: 'Second rule',
  shouldRun: () => true,
  validate: () => []
});

// Both rules will be discovered and registered
```

## Helper Functions

Create reusable validation helpers:

```typescript
import { defineCodeRule } from '../claude-code-validator';

// Helper function
function checkForPattern(content: string, pattern: RegExp, message: string): string | null {
  if (pattern.test(content)) {
    return message;
  }
  return null;
}

export const helperRule = defineCodeRule({
  name: 'helper-rule',
  description: 'Uses helper functions',
  shouldRun: (context) => context.filePath.endsWith('.ts'),

  validate(context) {
    const errors: string[] = [];

    const error1 = checkForPattern(
      context.content,
      /console\.log/,
      '‚ùå console.log is not allowed'
    );

    const error2 = checkForPattern(
      context.content,
      /debugger/,
      '‚ùå debugger statement is not allowed'
    );

    if (error1) errors.push(error1);
    if (error2) errors.push(error2);

    return errors;
  }
});
```

## File Organization

Organize rules by domain:

```
.claude/rules/
‚îú‚îÄ‚îÄ vue/
‚îÇ   ‚îú‚îÄ‚îÄ components.ts       # Component-related rules
‚îÇ   ‚îú‚îÄ‚îÄ props.ts            # Prop validation rules
‚îÇ   ‚îî‚îÄ‚îÄ composables.ts      # Composables rules
‚îú‚îÄ‚îÄ typescript/
‚îÇ   ‚îú‚îÄ‚îÄ imports.ts          # Import rules
‚îÇ   ‚îî‚îÄ‚îÄ types.ts            # Type rules
‚îî‚îÄ‚îÄ security/
    ‚îú‚îÄ‚îÄ xss.ts              # XSS prevention
    ‚îî‚îÄ‚îÄ secrets.ts          # Secret detection
```

All files are automatically discovered regardless of directory structure!

## Testing Rules

Create tests alongside your rules:

```typescript
// .claude/validators/tests/my-rule.test.ts
import { describe, it, expect } from 'vitest';
import { myRule } from '../rules/my-rule';

describe('My Rule', () => {
  it('should detect bad pattern', () => {
    const context = {
      toolName: 'Write',
      filePath: 'test.ts',
      content: 'bad-pattern here',
      operation: 'write' as const
    };

    const errors = myRule.validate(context);
    expect(errors).toHaveLength(1);
    expect(errors[0]).toContain('bad-pattern');
  });

  it('should pass with good code', () => {
    const context = {
      toolName: 'Write',
      filePath: 'test.ts',
      content: 'good-pattern here',
      operation: 'write' as const
    };

    const errors = myRule.validate(context);
    expect(errors).toHaveLength(0);
  });
});
```

## Best Practices

1. **Be specific** - Clear error messages with actionable suggestions
2. **Use shouldRun()** - Don't waste time running rules on irrelevant files
3. **Keep it simple** - One rule per concern
4. **Test thoroughly** - Write tests for edge cases
5. **Document patterns** - Add comments explaining complex regex
6. **Use helpers** - Extract common validation logic
7. **Format errors** - Use consistent emoji and formatting
8. **Provide examples** - Include example fixes in error messages
